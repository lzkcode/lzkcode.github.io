[{"title":"MySQL基础篇","url":"/2022/07/20/MySQL基础篇/","content":"\nMySQL属于关系型数据库（RDBMS），它是建立在关系模型基础上，由多张相互连接的二维表组成的数据库。\n\n**在IDEA中连接数据库，需要先设置时区，将serverTimezone改为Asia/Shanghai**\n\n思维导图\n\n<img src=\"./MySQL基础篇/学习大纲.png\" alt=\"学习大纲\" style=\"zoom:60%;\" />\n\n关系型数据库（RDBMS）：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。\n\n**在IDEA中连接数据库，需要先设置时区，将serverTimezone改为Asia/Shanghai**\n\n---\n\n### 1. SQL\n\nSQL语句分为以下4类：\n\n- 数据定义语言（DDL）：用来定义数据库对象，包括数据库，表，字段等。\n- 数据操作语言（DML）：用来对数据库表中的数据进行增删改。\n- 数据查询语言（DQL）：用来查询数据库中表的记录。\n- 数据控制语言（DCL）：用来创建数据库用户，控制数据库访问权限。\n\n#### 1.1 DDL定义语句\n\n#####  1.1.1 数据库操作\n\n|      操作      | SQL语句                                                      |\n| :------------: | :----------------------------------------------------------- |\n| 查询所有数据库 | `SHOW DATABASES;`                                            |\n| 查询当前数据库 | `SELECT DATABASE();`                                         |\n|   创建数据库   | `CREATE DATABASE [IF NOT EXISTS] 数据库名称 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];` |\n|   删除数据库   | `DROP DATABASE [IF EXISTS] 数据库名;`                        |\n|   使用数据库   | `USE 数据库名;`                                              |\n\n##### 1.1.2 表操作\n\n|            操作            | SQL语句                                                      |\n| :------------------------: | :----------------------------------------------------------- |\n|    查询当前数据库所有表    | `SHOW TABLES;`                                               |\n|         查询表结构         | `DESC 表名;`                                                 |\n|    查询指定表的建表语句    | `SHOW CREATE TABLE 表名;`                                    |\n|           创建表           | `CREATE TABLE 表名(字段 字段类型 [COMMENT 字段注释],字段 字段类型)[COMMENT 表注释];` |\n|          修改表名          | `ALTER TABLE 表名 RENAME TO 新表名;`                         |\n|           删除表           | `DROP TABLE [IF EXISTS] 表名;`                               |\n| 删除指定表，并重新创建该表 | `TRUNCATE TABLE 表名;`                                       |\n\n演示创建表：\n\n```mysql\nCREATE TABLE 表名(\n\tid INT COMMENT `编号`,\n\tname VARCHER(10) COMMENT `姓名`\n) CIMMENT `用户表`;\n```\n\n##### 1.1.3 字段操作\n\n|         操作         | SQL语句                                                      |\n| :------------------: | ------------------------------------------------------------ |\n|       添加字段       | `ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];` |\n|     修改数据类型     | `ALTER TABLE 表名 MODIFY 字段名 新数据类新(长度);`           |\n| 修改字段名和字段类型 | `ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束];` |\n|       删除字段       | `ALTER TABLE 表名 DROP 字段名;`                              |\n\n#### 1.2 DML操作语句\n\n|        操作        | SQL语句                                                      |\n| :----------------: | ------------------------------------------------------------ |\n| 给指定字段添加数据 | `INSERT INTO 表名(字段名1，字段名2) VALUES (值1，值2),(值1，值2);` |\n| 给全部字段添加数据 | `INSERT INTO 表名 VALUES(值1，值2),(值1，值2);`              |\n|      修改数据      | `UPDATE 表名 SET 字段名1=值1,字段名2=值2,...[WHERE 条件];`   |\n|      删除数据      | `DELETE FROM 表名 [WHERE 条件];`                             |\n\n#### 1.3 DQL查询语句\n\n##### 1.3.1 基础查询\n\n|     操作     | SQL语句                                              |\n| :----------: | ---------------------------------------------------- |\n| 查询多个字段 | `SELECT 字段1,字段2 FROM 表名;`                      |\n| 查询所有字段 | `SELECT * FROM 表名;`                                |\n|   设置别名   | `SELECT 字段1 [AS 别名1],字段2[AS 别名2] FROM 表名;` |\n| 去除重复记录 | `SELECT DISTINCT 字段列表 FROM 表名;`                |\n\n##### 1.3.2 条件查询\n\n语法：`SELECT 字段列表 FROM 表名 WHERE 条件列表;`\n\n条件：\n\n|       比较运算符        | 功能                                       |\n| :---------------------: | ------------------------------------------ |\n| >，>=，<，<=，=，<>或!= | 比较                                       |\n|    BETWEEN...AND...     | 在某范围之内（含最小，最大值）             |\n|         IN(...)         | 在列表中的值，多选一                       |\n|       LINK 占位符       | 模糊匹配（_匹配单个字符，%匹配任意个字符） |\n|         IS NULL         | 是NULL                                     |\n\n| 逻辑运算符 | 功能                         |\n| :--------: | ---------------------------- |\n| AND 或 &&  | 并且（多个条件同时成立）     |\n| OR 或 \\|\\| | 或者（多个条件任意一个成立） |\n| NOT 或 ！  | 非，不是                     |\n\n例子：\n\n查询id大于等于18：`SELECT * FROM emp WHERE id>=18;`\n\n查询idcard为非空：`SELECT * FROM emp WHERE idcard IS NOT NULL;`\n\n查询年龄在18到24岁：\n\n```mysql\nSELECT * FROM emp WHERE age>=18 AND age<=24;\nSELECT * FROM emp WHERE age BETWEEN 18 AND 24;\n```\n\n查询年龄小于18岁的男生：`SELECT * FROM emp WHERE age<18 AND gender='男';`\n\n查询年龄等于20，40，60岁：\n\n```mysql\nSELECT * FROM emp WHERE age=20 OR age=40 or age=60;\nSELECT * FROM emp WHERE age IN(20,40,60);\n```\n\n查询名字两个字的：`SELECT * FROM emp WHERE name LIKE '__'`\n\n查询idcard最后一位为X：`SELECT * FROM WHERE idcard LIke '%X';`\n\n##### 1.3.3 聚合函数\n\n将一列数据作为一个整体，进行纵向计算。\n\n语法：`SELECT 聚合函数(字段列表) FROM 表名;`\n\n常见聚合函数：\n\n| 函数  |   功能   |                     例子                      |\n| :---: | :------: | :-------------------------------------------: |\n| count | 统计数量 |          `SELECT COUNT(1) FROM emp;`          |\n|  max  |  最大值  |          `SELECT MAX(age) FROM emp;`          |\n|  min  |  最小值  |          `SELECT MIN(age) FROM emp;`          |\n|  avg  |  平均值  |          `SELECT AVG(age) FROM emp;`          |\n|  sum  |   求和   | `SELECT SUM(age) FROM emp WHERE gender='男';` |\n\n##### 1.3.4 分组查询\n\n语法：`SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];`\n\nWHERE和HAVING的区别：执行时机不同，where是分组之前进行过滤，不满足where条件不参与分组；having是分组后的结果进行过滤。判断条件不同，where不能对聚合函数进行判断，having可以。\n\n例子：\n\n```mysql\n#根据性别分组，统计男女员工数量\nSELECT gender,count(1) FROM emp GROUP BY gender;\n#年龄小于45，并按工作地址分组，获取员工数量大于3的工作地址\nSELECT address FROM emp WHERE age<45 GROUP BY address HAVING count(1)>3;\n```\n\n##### 1.3.5 排序查询\n\n语法：`SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;`\n\n排序方式：ASC 升序（默认）；DESC：降序；\n\n```mysql\n#根据age升序，如果age相同，按entrydate降序\nSELECT * FROM emp ORDER BY age ASC,entrydate DESC;\n```\n\n##### 1.3.6 分页查询\n\n语法：`SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;`\n\n注意：起始索引从0开始，起始索引 = (查询页码-1) * 每页显示记录数\n\n例子：\n\n```mysql\n#查询第1页，每页10条数据\nSELECT * FROM emp LIMIT 0,10;\n#查询第2页，每页10条数据\nSELECT * FROM emp LIMIT 10,10;\n```\n\n#### 1.4 DCL管理语句\n\n用户管理\n\n|     功能     | SQL语句                                                      |\n| :----------: | ------------------------------------------------------------ |\n| 查询用户信息 | `USE mysql; SELECT * FROM user;`                             |\n|   创建用户   | `CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';`        |\n| 修改用户密码 | `ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';` |\n|   删除用户   | `DROP USER '用户名'@'主机名';`                               |\n\n权限控制\n\n|   功能   | SQL语句                                                    |\n| :------: | ---------------------------------------------------------- |\n| 查询权限 | `SHOW GRANTS FOR '用户名'@'主机名';`                       |\n| 授予权限 | `GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';`    |\n| 撤销权限 | `REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';` |\n\n---\n\n### 2. 函数\n\n函数是指一段可以直接被另一端程序调用的程序或代码。\n\n#### 2.1 字符串函数\n\n|               函数               |                           功能                           |\n| :------------------------------: | :------------------------------------------------------: |\n|       CONCAT(S1,S2,...,Sn)       |        字符串拼接，将S1,S2,...,Sn拼接成一个字符串        |\n|      LOWER(str)，UPPER(str)      |               将字符串str全部转为小写/大写               |\n| LPAD(str,n,pad)，RPAD(str,n,pad) | 左/右填充，用字符串pad对str的左边填充，达到n个字符的长度 |\n|            TRIM(str)             |                去掉字符串头部和尾部的空格                |\n|     SUBSTRING(str,start,len)     |     返回从字符串str从start位置起的len个长度的字符串      |\n\n#### 2.2 数值函数\n\n|       函数        |                功能                |\n| :---------------: | :--------------------------------: |\n| CEIL(x)，FLOOR(x) |         向上取整，向下取整         |\n|     MOD(x,y)      |            返回x/y的模             |\n|      RAND()       |         返回0~1内的随机数          |\n|    ROUND(x,y)     | 求参数x的四舍五入的值，保留y位小数 |\n\n#### 2.3 日期函数\n\n|                函数                |                       功能                        |\n| :--------------------------------: | :-----------------------------------------------: |\n|    CURDATE()，CURTIME()，NOW()     |           返回当前日期/时间/日期和时间            |\n| YEAR(date)，MONTH(date)，DAY(date) |           获取指定date的年份/月份/日期            |\n| DATE_ADD(date,INTERVAL expr type)  | 返回一个日期/时间值加上一个时间间隔expr后的时间值 |\n|       DATEDIFF(date1,date2)        |    返回起始时间date1和结束时间date2之间的天数     |\n\n#### 2.4 流程函数\n\n|                            函数                            |                           功能                            |\n| :--------------------------------------------------------: | :-------------------------------------------------------: |\n|                       IF(value,t,f)                        |            如果value为true，则返回t，否则返回f            |\n|                   IFNULL(value1,value2)                    |       如果value1不为空，返回value1，否则返回value2        |\n|    CASE WHEN [val1] THEN [res1] ... ELSE [default] END     |    如果val1为true，返回res1，...否则返回default默认值     |\n| CASE [expr] WHEN [val1] THEN [res1] ... ELSE [default] END | 如果expr的值等于val1，返回res1，... 否则返回default默认值 |\n\n---\n\n### 3.约束\n\n概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\n\n目的：保证数据库中数据的正确性，有效性和完整性。\n\n分类：在创建表/修改表的时候添加约束(AUTO_INCREMENT 自动增长)\n\n|        约束        |                           描述                           |   关键字    |\n| :----------------: | :------------------------------------------------------: | :---------: |\n|      非空约束      |                 限制字段的数据不能为null                 |  NOT NULL   |\n|      唯一约束      |            保证字段的数据都是唯一的，不重复的            |   UNIQUE    |\n|      主键约束      |            一行数据的唯一标识，要求非空且唯一            | PRIMARY KEY |\n|      默认约束      |      保存数据时，如果未指定该字段的值，则采用默认值      |   DEFAULT   |\n| 检查约束（8.0.16） |                 保证字段值满足某一个条件                 |    CHECK    |\n|      外键约束      | 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 | FOREIGN KEY |\n\n外键约束，主表列名必须为主键\n\n```mysql\n#添加外键\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)\n#删除外键\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称\n```\n\n外键删除和更新行为，注意！外键约束会降低性能，工作一般在代码中使用逻辑外键\n\n|   行为   |                             说明                             |\n| :------: | :----------------------------------------------------------: |\n| CASCADE  | 当父表删除/更新对应记录时，先检查该记录是否有对应外键，如果有则页删除/更新外键所在子表的记录 |\n| SET NULL | 当父表删除对应记录时，先检查该记录是否有对应外键，如果有则设置子表中的外键值为NULL（允许取NULL） |\n\n```mysql\n#更新行为改为CASCADE，删除行为改为SET NULL\nALTER TABLE emp ADD CONSTRAINT id FOREIGN KEY (dept_id) REFERENCES dept(id) ON UPDATE CASCADE ON DELETE SET NULL;\n```\n\n---\n\n### 4. 多表查询\n\n#### 4.1 三种表结构的实现\n\n- 一对多：在多的一方建立外键，指向一的一方的主键。\n\n- 多对多：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键。\n\n- 一对一：在任意一方加入外键，关联另外一方的主键，并设置外键为唯一（UNIQUE）。\n\n笛卡尔积：指两个集合的所有组合情况。在多表查询的时候需要消除无效的笛卡尔积。\n\n#### 4.2 连接查询\n\n##### 4.2.1 内连接\n\n查询到两表交集的数据\n\n```mysql\nSELECT 字段列表 FROM 表1,表2 WHERE 条件;\t//隐式内连接\nSELECT 字段列表 FROM 表1 INNER JOIN 表2 ON 连接条件;\t//显式内连接\n```\n\n##### 4.2.2 外连接\n\n查询到表1的全部数据和表2中与表1交集的数据\n\n```mysql\nSELECT 字段列表 FROM 表1 LEFT OUTER JOIN 表2 ON 连接条件;\t//左外连接\nSELECT 字段列表 FROM 表1 RIGHT OUTER JOIN 表2 ON 连接条件;\t//右外连接\n```\n\n##### 4.2.3 自连接\n\n自连接查询，可以是内连接查询，也可以是外连接查询。\n\n```mysql\nSELECT 字段列表 FROM 表1 别名1,表2 别名2 WHERE 条件;\nSELECT 字段列表 FROM 表1 别名1 JOIN 表1 别名2 ON 条件;\n```\n\n#### 4.3 联合查询\n\nunion查询就是把多次查询的结果合并起来，形成一个新的查询结果集。\n\n```mysql\nSELECT 字段列表 FROM 表1 ...\nUNION [ALL]\t#不加ALL可以去重\nSELECT 字段列表 FROM 表2 ...\n```\n\n联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。\n\nunion all会将全部数据直接合并在一起，union会对合并后的数据去重。\n\n#### 4.4 嵌套查询\n\nSQL语句中嵌套SELECT语句，称为嵌套查询或子查询。\n\n```mysql\nSELECT * FROM 表1 WHERE 值1 = (SELECT 值1 FROM 表2);\n```\n\n根据子查询位置，可分为：WHERE之后，FROM之后，SELECT之后。\n\n根据子查询结果不同，可分为：\n\n- 标量子查询（子查询结果为单个值）\n\n  ```mysql\n  SELECT id FROM dept WHERE name = '销售部';\t#查询销售部id\n  SELECT * FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = '销售部');\n  ```\n\n  常见操作符：>，>=，<，<=，=，!=\n\n- 列子查询（子查询结果为一列）\n\n  ```mysql\n  SELECT id FROM dept WHERE name = '销售部' OR name = '市场部';\n  SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE name = '销售部' OR name = '市场部');\n  ```\n\n  常用操作符：\n\n  |    操作符    | 描述                         |\n  | :----------: | ---------------------------- |\n  | IN（NOT IN） | 在（不在）指定的集合范围之内 |\n  |   ANY/SOME   | 有任意一个满足即可           |\n  |     ALL      | 所有值都必须满足             |\n\n- 行子查询（子查询结果为一行）\n\n  ```mysql\n  SELECT salary,managerid FROM emp WHERE name = '张无忌';\n  SELECT * FROM emp WHERE (salary,managerid) = (SELECT salary,managerid FROM emp WHERE name = '张无忌');\n  ```\n\n  常见操作符：=，!=，IN，NOT IN\n\n- 表子查询（子查询结果为多行多列）\n\n  ```mysql\n  SELECT job,salary FROM emp WHERE name = '张三丰' OR name = '张无忌';\n  SELECT * FROM emp WHERE (job,salary) IN (SELECT job,salary FROM emp WHERE name = '张三丰' OR name = '张无忌');\n  ```\n\n  常用操作符：IN\n\n---\n\n### 5. 事务\n\n事务是一组操作集合，它是不可分割的工作单位，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求。\n\n默认MySQL的事务是自动提交的，当执行一条DML语句，MySQL会立即隐式提交。\n\n#### 5.1 事务操作\n\n方法1：设置事务提交方式\n\n```mysql\nSELECT @@autocommit;\t#查看事务提交方式,1为自动提交\nSET @@autocommit=0;\t\t#设置事务提交方式为0，手动提交\n```\n\n方法2：开启事务（提交或回滚后就结束）\n\n```mysql\nSTART TRANSACTION;\n```\n\n执行DML语句报错则使用回滚，否则提交数据。\n\n```mysql\nCOMMIT;\t\t#手动提交\nROLLBACK;\t#事务回滚\n```\n\n#### 5.2 四大特性\n\n1. 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。\n2. 一致性（Consistency）：事务完成时，必须使所有的数据保持一致状态。\n3. 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\n4. 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变是永久的。\n\n#### 5.3 并发事务问题\n\n|    问题    |                             描述                             |\n| :--------: | :----------------------------------------------------------: |\n|    脏读    |            一个事务读到另一个事务还没提交的数据。            |\n| 不可重复读 | 一个事务先后读取同一个记录，但两次读取的数据不同，称为不可重复读 |\n|    幻读    | 一个事务按照条件查询时，没有对应的数据行，但在插入数据时，又发现这行数据已经存在，好像出现了幻影 |\n\n#### 5.4 事务隔离级别\n\n事务隔离级别用来解决并发事务问题\n\n|           隔离级别           | 脏读 | 不可重复读 | 幻读 |\n| :--------------------------: | :--: | :--------: | :--: |\n|  Read uncommitted（不安全）  |  有  |     有     |  有  |\n| Read committed（Oracle默认） | 没有 |     有     |  有  |\n| Repeatable Read（MySQL默认） | 没有 |    没有    |  有  |\n|    Serializable（效率低）    | 没有 |    没有    | 没有 |\n\n```mysql\n#查看事务隔离级别\nSELECT @@TRANSACTION_ISOLATION;\n#设置事务隔离级别\nSET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL {Read uncommitted|Read committed|Repeatable Read|Serializable};\t#SESSION只针对当前客户端窗口有效;GLOBAL针对所有客户端有效\n```\n\n---\n\n","tags":["MySQL"],"categories":["数据库"]},{"title":"Singleton_单例模式","url":"/2022/07/20/Singleton-单例模式/","content":"\n应用场景：在程序只需要有一个实例存在的时候，比如各种[MGR](https://blog.csdn.net/n88Lpo/article/details/122659661)，各种[Factory](https://blog.csdn.net/jisuanji198509/article/details/80401303)。你可以在编写代码的时候只创建一个实例，但如何保证其他人不能通过构造器new一个新的实例呢？答案是通过单例模式实现。\n\n单例的实现方式大体分为三种：饿汉式，懒汉式，枚举单例。\n\n### 1. 饿汉式\n\n类加载到内存后，就实例化一个单例，JVM会保证线程安全。这个实现方式简单实用，唯一缺点是不管用到与否，类装载时就完成实例化，可以利用**加载外部类时不会加载内部类**的特性来实现懒加载，达到了按需初始化的目的，推荐大家使用。\n\n```java\npublic class Demo{\n    private Demo(){};\n    private static class DemoHolder{\n        private final static Demo INSTANCE = new Demo();\n    }\n    public static Demo getInstance(){ return DemoHolder.INSTANCE; }\n}\n```\n\n定义一个Demo常量，并将Demo常量和Demo**构造器都声明为private私有**，只提供一个实例常量的静态访问器用于访问该实例。构造器被声明为私有则只能在类里面调用，外面无法使用构造器创建新实例。\n\n### 2. 懒汉式\n\n懒汉式lazy looding，虽然达到了按需初始化的目的，但却带来了线程不安全的问题，可以通过双重效验锁来解决线程不安全问题，但也带来了效率下降，不推荐使用。\n\n```java\npublic class Demo{\n    private static Demo INSTANCE;\n    private Demo() {};\n    public static Demo getInstance(){\n        if(INSTANCE == null){\n            synchronized (Demo.class){\n                if(INSTANCE == null){ INSTANCE = new Demo(); }\n            }\n        }\n        return INSTANCE;\n    }\n}\n```\n\n### 3. 枚举单例\n\nJava创始人之一Joshua Bloch在《Effective Java》中写了一种新的单例的实现方式，使用枚举来实现单例。不仅可以解决线程同步，还可以防止反序列化，因为枚举类没有构造器。\n\n```java\npublic enum Demo{\n    INSTANCE;\n    //使用\n    public static void main(String[] args) {\n        System.out.println(Demo.INSTANCE.hashCode());\n    }\n}\n```\n\n三种实现单例的方式介绍完毕。","tags":["单例"],"categories":["设计模式"]},{"title":"个人博客搭建指南","url":"/2022/07/19/个人博客搭建指南/","content":"\n---\n\n​\t\t经过两天的折腾，终于把个人博客搭建成了。这个个人博客使用Hexo框架搭配Github搭建而成。写这篇博客进行记录总结，可以帮助你快速搭建一个个人博客，包括解决图片上传问题，如何更改主题，如何发布文章等...\n\n### 1. 搭建博客需要的工具\n\n在开始搭建个人博客之前先准备好所需要的工具\n\n- [Node.js下载](https://nodejs.org/zh-cn/download/)\n\n- [Git下载](https://git-scm.com/downloads)\n\n安装成功并配置好环境变量后，在命令行执行以下命令开始下载Hexo\n\n```\nnpm install hexo-cli -g\n```\n\n### 2. 新建博客的仓库\n\n利用Github的仓库作为我们Hexo博客的服务器，用来存储数据文件。\n\n- 仓库名的格式必须为`github用户名.github.io`\n- 勾选 Add a README file，其他默认即可点击create新建仓库。\n\n建完仓库后新建一个文件夹作为本地仓库，在本地仓库右键选择Git Bash Here打开git的小黑窗口，键入以下命令生成.ssh文件\n\n```bash\nssh-keygen -t rsa -C \"m13750454052@163.com\"\n```\n\n字符串是创建github时的邮件地址，第一次创建直接四次回车就生成成功。生成的公钥在`C:\\Users\\User\\.ssh`目录下的`id_rsa.pub`文件中，使用公钥创建github的SSH Key，在小黑窗口键入以下命令测试是否绑定成功，yes\n\n```bash\nssh -T git@github.com\n```\n\n### 3. 生成并发布博客\n\n1. 在本地仓库的小黑窗口键入`hexo init`初始化Hexo博客，注意这步可能出现连接错误多试几遍就可以了。\n\n2. 使用`hexo s`命令启动服务，此时可以使用 http://localhost:4000/ 访问本地博客。\n\n3. 修改本地仓库中的`_config.yml`配置文件中的deploy。\n\n   ```yaml\n   deploy:\n    type: git\n    repository: https://github.com/linzk996/linzk996.github.io.git\n    branch: main\n   ```\n\n4. 安装自动部署发布工具，在本地仓库的小黑窗口中键入以下命令进行安装。\n\n   ```bash\n   npm install hexo-deployer-git --save\n   ```\n\n5. 使用`hexo g`生成博客页面，使用`hexo d`发布到远程仓库，过程中可能出现连接错误，多试几次就可以了，或者科学上网。\n\n6. 第一次发布会有一个验证操作，需要把密码换成令牌，在GitHub中找到developer settings->personal access token可生成令牌。\n\n7. 博客发布成功，访问博客地址：https://lzkcode.github.io/\n\n到此博客搭建完成，接下来开始发布文章吧！\n\n---\n\n### 4. 发布文章\n\n博客搭建完成后怎么发布文章呢？\n\n1. 在本地仓库的小黑窗口中键入以下命令创建一个post\n\n   ```bash\n   hexo new \"My New Post\"\n   ```\n\n   执行后在本地仓库的`/source/_posts`目录中会生成一个md文件，现在可以开始编写你的文章。\n\n2. 编写完成后就可以使用`hexo s`创建本地服务器，使用`hexo g`生成静态文件，使用`hexo d`部署到远程站点。\n\n到此文章已经发送成功，注意！！国内虽然不科学上网也能访问Github但网速拉跨，如果发布完没效果请给它2分钟时间...\n\n---\n\n### 5. 解决上传图片问题\n\n此时你的文章还不能插入图片，接下来给出解决方案如下\n\n1. 修改`_config.yml`文件中的`post_asset_folder : true`，这样你新建文章的时候会有一个同名文件夹用来放资源。\n\n2. `cmd`调出DOS窗口执行命令`npm i -g yarn`安装yarn用来下载`hexo-assets-image`\n\n3. 在本地仓库的小黑窗口执行以下命令进行安装\n\n   ```bash\n   1. yarn add https://github.com/CodeFalling/hexo-asset-image --save\n   ```\n\n4. 把图片放在同名文件夹里引用，`md`里引用图片用 ./文章名/图片名 （注意！！是用斜杠而不是反斜杠）\n\n   ![avatar](./个人博客搭建指南/avatar.png)\n\n到此文章就可以插入图片了，接下来学习如何修改博客主题！！！\n\n---\n\n### 6. 修改博客主题\n\n你可以到[Hexo官网](https://hexo.io/themes/)挑选自己喜欢的主题，主题里面应该有链接可以传送到主题的Github，根据里面的提示完成主题的使用。\n\n1. 将主题克隆到theme文件夹，可以使用下面的命令\n\n   ```bash\n   git clone https://github.com/liuyib/hexo-theme-stun.git themes/stun\n   ```\n\n2. 修改`_config.yml`文件中的theme为`theme：stun`就启用了该主题，可以使用`hexo clean`打扫一下仓库\n\n3. 根据主题的文档说明来配置主题样式，我这个博客使用的[主题stun的文档](https://theme-stun.github.io/docs/zh-CN/)\n\n---\n\n","tags":["blog"],"categories":["环境搭建"]}]